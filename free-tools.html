<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qlipper AI - Free Tools</title>
    <meta name="description"
        content="Free AI Video Clipper. Runs 100% in your browser using WebAssembly. No sign-up required.">
    <link rel="icon" type="image/png" href="assets/favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap"
        rel="stylesheet">
    <!-- Google Generative AI -->
    <script type="importmap">
      {
        "imports": {
          "@google/generative-ai": "https://esm.run/@google/generative-ai"
        }
      }
    </script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        royal: {
                            900: '#0c0c14',
                            950: '#050508',
                            1000: '#050505'
                        },
                        gold: {
                            400: '#fbbf24',
                            500: '#f59e0b',
                            600: '#d97706'
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif']
                    }
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #050505;
        }

        .grid-bg {
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 32px 32px;
        }

        .gradient-gold {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        /* Custom Scrollbar for logs */
        .scrollbar-thin::-webkit-scrollbar {
            width: 6px;
        }

        .scrollbar-thin::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        .scrollbar-thin::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
    </style>
</head>

<body class="bg-royal-1000 text-gray-100 antialiased grid-bg min-h-screen flex flex-col">

    <!-- Header -->
    <header class="py-6 px-6 border-b border-white/5 bg-royal-1000/80 backdrop-blur-xl sticky top-0 z-50">
        <div class="max-w-4xl mx-auto flex items-center justify-between">
            <a href="index.html" class="flex items-center gap-3">
                <img src="assets/logo.png" alt="Qlipper AI" class="w-8 h-8 rounded-lg">
                <span class="font-extrabold tracking-tight">Qlipper Free Tools</span>
            </a>
            <div class="flex items-center gap-4">
                <a href="https://aistudio.google.com/app/apikey" target="_blank"
                    class="text-xs text-gray-400 hover:text-white underline">Get Gemini Key</a>
                <a href="offer.html"
                    class="bg-white/10 hover:bg-white/20 text-white text-xs font-bold px-4 py-2 rounded-lg transition">Get
                    Pro Version</a>
            </div>
        </div>
    </header>

    <main class="flex-grow px-6 py-12">
        <div class="max-w-2xl mx-auto space-y-8">

            <!-- Hero -->
            <div class="text-center mb-10">
                <h1 class="text-3xl md:text-5xl font-black mb-4">Client-Side AI Clipper</h1>
                <p class="text-gray-400">Process videos 100% locally in your browser using FFmpeg WASM + Gemini Flash.
                </p>
            </div>

            <!-- Configuration Card -->
            <div class="bg-white/5 border border-white/10 rounded-3xl p-6 md:p-8 backdrop-blur-sm">
                <!-- Step 1: API Key -->
                <div class="mb-8">
                    <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider mb-2">1. Google Gemini
                        API Key</label>
                    <div class="relative">
                        <input type="password" id="apiKey" placeholder="Paste your API Key here (starts with AIza...)"
                            class="w-full bg-black/40 border border-white/10 rounded-xl px-4 py-3 text-sm text-white focus:outline-none focus:border-gold-500 transition">
                        <button id="saveKeyBtn"
                            class="absolute right-2 top-1.5 text-xs bg-white/10 hover:bg-white/20 text-white px-3 py-1.5 rounded-lg transition">Save</button>
                    </div>
                    <p class="text-[10px] text-gray-500 mt-2">Key is stored locally in your browser. We never see it.
                    </p>
                </div>

                <!-- Step 2: Video Input -->
                <div class="mb-8">
                    <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider mb-2">2. Video
                        Source</label>

                    <!-- Tabs -->
                    <div class="flex gap-4 mb-4 border-b border-white/10 pb-2">
                        <button class="text-sm font-bold text-gold-400 border-b-2 border-gold-400 pb-2">Upload
                            File</button>
                        <button class="text-sm font-bold text-gray-500 pb-2 cursor-not-allowed"
                            title="YouTube direct download requires a backend proxy. Use the desktop app for this.">YouTube
                            Link (Pro App Only)</button>
                    </div>

                    <div class="border-2 border-dashed border-white/10 rounded-xl p-8 text-center hover:border-gold-500/50 transition cursor-pointer"
                        id="dropZone">
                        <input type="file" id="videoUpload" accept="video/*" class="hidden">
                        <div class="text-4xl mb-2">üìÅ</div>
                        <p class="text-sm font-bold text-white">Click to upload video</p>
                        <p class="text-xs text-gray-500 mt-1">MP4, WebM, MOV supported</p>
                    </div>
                </div>

                <!-- Step 3: Action -->
                <button id="processBtn" disabled
                    class="w-full gradient-gold text-black font-black py-4 rounded-xl text-lg shadow-lg shadow-gold-500/20 opacity-50 cursor-not-allowed transition hover:scale-[1.02]">
                    Analyze & Clip Video ‚ö°
                </button>

                <!-- Status / Logs -->
                <div id="statusArea"
                    class="hidden mt-6 bg-black/60 rounded-xl p-4 font-mono text-xs text-gray-400 max-h-40 overflow-y-auto scrollbar-thin">
                    <div id="logs" class="space-y-1"></div>
                </div>
            </div>

            <!-- Output Area -->
            <div id="outputArea" class="hidden space-y-4">
                <h3 class="text-xl font-bold">Generated Clips</h3>
                <div id="clipsGrid" class="grid gap-4">
                    <!-- Clips will be injected here -->
                </div>
            </div>

        </div>
    </main>

    <footer class="py-8 border-t border-white/5 text-center px-6">
        <p class="text-xs text-gray-500">
            Powered by FFmpeg WASM & Gemini 1.5 Flash. <br>
            For unlimited YouTube downloads and automated subtitles, <a href="offer.html"
                class="text-gold-400 hover:underline">get the Desktop App</a>.
        </p>
    </footer>

    <!-- Logic -->
    <script type="module">
        import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";
        // Import FFmpeg from CDN manually since imports are tricky in plain HTML
        // We will load scripts via script tags in head

        // DOM Elements
        const apiKeyInput = document.getElementById('apiKey');
        const saveKeyBtn = document.getElementById('saveKeyBtn');
        const videoUpload = document.getElementById('videoUpload');
        const dropZone = document.getElementById('dropZone');
        const processBtn = document.getElementById('processBtn');
        const statusArea = document.getElementById('statusArea');
        const logsDiv = document.getElementById('logs');
        const outputArea = document.getElementById('outputArea');
        const clipsGrid = document.getElementById('clipsGrid');

        // State
        let ffmpeg = null;
        let videoFile = null;
        let genAI = null;

        // --- Init ---
        // Load API Key
        const savedKey = localStorage.getItem('qlipper_gemini_key');
        if (savedKey) {
            apiKeyInput.value = savedKey;
            checkReady();
        }

        // --- Handlers ---
        saveKeyBtn.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            if (key) {
                localStorage.setItem('qlipper_gemini_key', key);
                log('API Key saved locally.');
                checkReady();
            }
        });

        dropZone.addEventListener('click', () => videoUpload.click());
        videoUpload.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                videoFile = e.target.files[0];
                log(`Selected file: ${videoFile.name} (${(videoFile.size / 1024 / 1024).toFixed(2)} MB)`);
                dropZone.classList.add('border-gold-500');
                checkReady();
            }
        });

        function checkReady() {
            if (apiKeyInput.value && videoFile) {
                processBtn.disabled = false;
                processBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        function log(msg) {
            statusArea.classList.remove('hidden');
            const div = document.createElement('div');
            // Timestamp
            const time = new Date().toLocaleTimeString();
            div.textContent = `[${time}] ${msg}`;
            logsDiv.appendChild(div);
            logsDiv.scrollTop = logsDiv.scrollHeight;
        }

        // Load FFmpeg Script dynamically if needed, but it's in head
        async function loadFFmpeg() {
            if (window.FFmpeg) return window.FFmpeg;
            // It should be loaded from CDN in head
            const script = document.createElement('script');
            script.src = "https://unpkg.com/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.js";
            document.head.appendChild(script);
            await new Promise(r => script.onload = r);

            const scriptUtil = document.createElement('script');
            scriptUtil.src = "https://unpkg.com/@ffmpeg/util@0.12.1/dist/umd/index.js";
            document.head.appendChild(scriptUtil);
            await new Promise(r => scriptUtil.onload = r);
        }

        // --- Core Logic ---
        processBtn.addEventListener('click', async () => {
            processBtn.disabled = true;
            processBtn.textContent = "Processing... (Do not close tab)";
            statusArea.classList.remove('hidden');

            try {
                // 1. Initialize FFmpeg
                if (!ffmpeg) {
                    log('Initializing FFmpeg Engine...');
                    // Ensure scripts are loaded
                    await loadFFmpeg();

                    const { FFmpeg } = window.FFmpeg;
                    const { toBlobURL } = window.FFmpegUtil;

                    ffmpeg = new FFmpeg();
                    ffmpeg.on('log', ({ message }) => {
                        // console.log(message); 
                    });

                    // Load ffmpeg.wasm from CDN
                    const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd';
                    await ffmpeg.load({
                        coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
                        wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
                    });
                    log('FFmpeg engine ready.');
                }

                // 2. Write file to memory
                log('Reading video file into memory...');
                const { fetchFile } = window.FFmpegUtil;
                await ffmpeg.writeFile('input.mp4', await fetchFile(videoFile));
                log('File loaded.');

                // 3. Extract Audio for Analysis (Faster to upload audio than video)
                log('Extracting audio track for AI analysis (this is fast)...');
                await ffmpeg.exec(['-i', 'input.mp4', '-vn', '-acodec', 'libmp3lame', 'audio.mp3']);
                const audioData = await ffmpeg.readFile('audio.mp3');
                const audioBlob = new Blob([audioData.buffer], { type: 'audio/mp3' });
                log(`Audio extracted: ${(audioBlob.size / 1024 / 1024).toFixed(2)} MB`);

                // 4. Gemini Analysis
                log('Sending audio to Google Gemini 1.5 Flash...');
                genAI = new GoogleGenerativeAI(apiKeyInput.value);
                const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

                // Convert blob to base64
                const base64Audio = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.readAsDataURL(audioBlob);
                });

                const prompt = `
                You are a professional video editor. Analyze this audio to find the most viral, interesting, or meaningful segments.
                Return exactly 3 clips.
                For each clip, provide:
                - title: short catchment title
                - start: start time in "MM:SS" format
                - end: end time in "MM:SS" format
                - reason: why this is a good clip
                
                Return the response strictly as a JSON array of objects. No markdown.
                Example: [{"title": "Intro", "start": "00:00", "end": "00:15", "reason": "Hook"}]
                `;

                const result = await model.generateContent([
                    prompt,
                    {
                        inlineData: {
                            mimeType: "audio/mp3",
                            data: base64Audio
                        }
                    }
                ]);

                const responseText = result.response.text();
                log('AI Analysis complete. Parsing results...');

                // Parse JSON (handle markdown stripping if needed)
                let cleanJson = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
                let segments;
                try {
                    segments = JSON.parse(cleanJson);
                } catch (e) {
                    log('JSON Parse failed. Raw response: ' + cleanJson.substring(0, 50));
                    throw new Error('Failed to parse AI response');
                }

                log(`Found ${segments.length} clips! Cutting now...`);

                // 5. Clip Generation
                outputArea.classList.remove('hidden');
                clipsGrid.innerHTML = ''; // Clear previous

                for (let i = 0; i < segments.length; i++) {
                    const seg = segments[i];
                    log(`CUTTING Clip ${i + 1}: "${seg.title}" (${seg.start} - ${seg.end})...`);

                    const startSeconds = timeToSeconds(seg.start);
                    const endSeconds = timeToSeconds(seg.end);
                    const duration = endSeconds - startSeconds;

                    if (duration <= 0) {
                        log(`Skipping invalid duration clip: ${seg.title}`);
                        continue;
                    }

                    const outName = `clip_${i + 1}.mp4`;

                    // FFmpeg Cut Command
                    await ffmpeg.exec([
                        '-ss', `${startSeconds}`,
                        '-i', 'input.mp4',
                        '-t', `${duration}`,
                        '-c', 'copy', // Stream copy for speed!
                        outName
                    ]);

                    // Read result
                    const data = await ffmpeg.readFile(outName);
                    const url = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));

                    // Create UI Card
                    const card = document.createElement('div');
                    card.className = 'bg-white/5 border border-white/10 rounded-xl p-4 flex flex-col sm:flex-row gap-4 items-center';
                    card.innerHTML = `
                        <video src="${url}" controls class="w-full sm:w-48 h-28 bg-black rounded-lg object-contain border border-white/10"></video>
                        <div class="flex-1 min-w-0 w-full">
                            <h4 class="font-bold text-white truncate text-lg">${seg.title}</h4>
                            <p class="text-xs text-gold-400 font-mono mb-2">${seg.start} - ${seg.end} (${duration}s)</p>
                            <p class="text-sm text-gray-400 line-clamp-2 mb-3">${seg.reason}</p>
                            <a href="${url}" download="qlipper_${seg.title.replace(/[^a-z0-9]/gi, '_')}.mp4" 
                               class="inline-block bg-gold-500 hover:bg-gold-400 text-black font-bold px-4 py-2 rounded-lg transition text-sm">
                               ‚¨á Download Clip
                            </a>
                        </div>
                    `;
                    clipsGrid.appendChild(card);
                }

                log('All Done! You can create more clips now.');
                processBtn.textContent = "Analyze & Clip Video ‚ö°";
                processBtn.disabled = false;

            } catch (e) {
                log(`ERROR: ${e.message}`);
                console.error(e);
                processBtn.textContent = "Error - Try Again";
                processBtn.disabled = false;

                // Show helpful error for common issues
                if (e.message.includes('SharedArrayBuffer')) {
                    log('CRITICAL: SharedArrayBuffer is not available. This site requires Cross-Origin-Opener-Policy: same-origin and Cross-Origin-Embedder-Policy: require-corp headers to function.');
                }
            }
        });

        // --- Helpers ---
        function timeToSeconds(timeStr) {
            const parts = timeStr.trim().split(':').map(Number);
            if (parts.length === 2) return parts[0] * 60 + parts[1];
            if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
            return 0;
        }

    </script>
</body>

</html>