<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qlipper AI - Free Tools</title>
    <meta name="description"
        content="Free AI Video Clipper. Runs 100% in your browser using WebAssembly. No sign-up required.">
    <link rel="icon" type="image/png" href="assets/favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap"
        rel="stylesheet">
    <!-- COI for GitHub Pages -->
    <script src="coi-serviceworker.js"></script>
    <!-- Google Generative AI -->
    <script type="importmap">
      {
        "imports": {
          "@google/generative-ai": "https://esm.run/@google/generative-ai"
        }
      }
    </script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        royal: {
                            900: '#0c0c14',
                            950: '#050508',
                            1000: '#050505'
                        },
                        gold: {
                            400: '#fbbf24',
                            500: '#f59e0b',
                            600: '#d97706'
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif']
                    }
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #050505;
        }

        .grid-bg {
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 32px 32px;
        }

        .gradient-gold {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        /* Custom Scrollbar for logs */
        .scrollbar-thin::-webkit-scrollbar {
            width: 6px;
        }

        .scrollbar-thin::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        .scrollbar-thin::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
    </style>
</head>

<body class="bg-royal-1000 text-gray-100 antialiased grid-bg min-h-screen flex flex-col">

    <!-- Header -->
    <header class="py-6 px-6 border-b border-white/5 bg-royal-1000/80 backdrop-blur-xl sticky top-0 z-50">
        <div class="max-w-4xl mx-auto flex items-center justify-between">
            <a href="index.html" class="flex items-center gap-3">
                <img src="assets/logo.webp" alt="Qlipper AI" class="w-8 h-8 rounded-lg">
                <span class="font-extrabold tracking-tight">Qlipper Free Tools</span>
            </a>
            <div class="flex items-center gap-4">
                <a href="https://aistudio.google.com/app/apikey" target="_blank"
                    class="text-xs text-gray-400 hover:text-white underline">Get Gemini Key</a>
                <a href="offer.html"
                    class="bg-white/10 hover:bg-white/20 text-white text-xs font-bold px-4 py-2 rounded-lg transition">Get
                    Pro Version</a>
            </div>
        </div>
    </header>

    <main class="flex-grow px-6 py-12">
        <div class="max-w-2xl mx-auto space-y-8">

            <!-- Hero -->
            <div class="text-center mb-10">
                <h1 class="text-3xl md:text-5xl font-black mb-4">You Link, We Clip.</h1>
                <p class="text-gray-400">Paste a YouTube link -> Download -> AI Auto-Clip. <br>100% Free &
                    Browser-based.</p>
            </div>

            <!-- Configuration Card -->
            <div class="bg-white/5 border border-white/10 rounded-3xl p-6 md:p-8 backdrop-blur-sm shadow-2xl">
                <!-- Step 1: API Key -->
                <div class="mb-8 p-4 bg-black/30 rounded-xl border border-white/5">
                    <label
                        class="block text-xs font-bold text-gray-400 uppercase tracking-wider mb-2 flex justify-between">
                        <span>1. Gemini API Key</span>
                        <span id="keyStatus" class="text-gray-500">Not Saved</span>
                    </label>
                    <div class="relative">
                        <input type="password" id="apiKey" placeholder="Paste AIza... key here"
                            class="w-full bg-black/40 border border-white/10 rounded-xl px-4 py-3 text-sm text-white focus:outline-none focus:border-gold-500 transition">
                        <button id="saveKeyBtn"
                            class="absolute right-2 top-1.5 text-xs bg-white/10 hover:bg-white/20 text-white px-3 py-1.5 rounded-lg transition">Save</button>
                    </div>
                </div>

                <!-- Step 2: Video Input -->
                <div class="mb-8">
                    <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider mb-2">2. Video
                        Source</label>

                    <!-- Tabs -->
                    <div class="flex gap-4 mb-4 border-b border-white/10 pb-2">
                        <button id="tabYoutube"
                            class="text-sm font-bold text-gold-400 border-b-2 border-gold-400 pb-2 transition">YouTube
                            Link</button>
                        <button id="tabFile"
                            class="text-sm font-bold text-gray-500 hover:text-white pb-2 transition">Upload
                            File</button>
                    </div>

                    <!-- YouTube Input -->
                    <div id="panelYoutube" class="block">
                        <div class="flex gap-2">
                            <input type="text" id="ytUrl" placeholder="https://www.youtube.com/watch?v=..."
                                class="flex-1 bg-black/40 border border-white/10 rounded-xl px-4 py-3 text-sm text-white focus:outline-none focus:border-gold-500 transition">
                            <button id="fetchYtBtn"
                                class="bg-white/10 hover:bg-white/20 text-white font-bold px-4 py-2 rounded-xl border border-white/10 transition">
                                Load
                            </button>
                        </div>
                        <p class="text-[10px] text-gray-500 mt-2">Uses public APIs to fetch video stream. Works best on
                            shorter videos (< 10min).</p>
                    </div>

                    <!-- File Input -->
                    <div id="panelFile"
                        class="hidden border-2 border-dashed border-white/10 rounded-xl p-8 text-center hover:border-gold-500/50 transition cursor-pointer"
                        onclick="document.getElementById('videoUpload').click()">
                        <input type="file" id="videoUpload" accept="video/*" class="hidden">
                        <div class="text-4xl mb-2">üìÅ</div>
                        <p class="text-sm font-bold text-white">Click to upload video</p>
                        <p class="text-xs text-gray-500 mt-1">MP4, WebM, MOV supported</p>
                    </div>
                </div>

                <!-- Step 3: Action -->
                <button id="processBtn" disabled
                    class="w-full gradient-gold text-black font-black py-4 rounded-xl text-lg shadow-lg shadow-gold-500/20 opacity-50 cursor-not-allowed transition hover:scale-[1.02]">
                    Start Magic Clipping ‚ú®
                </button>

                <!-- Status / Logs -->
                <div id="statusArea"
                    class="hidden mt-6 bg-black/60 rounded-xl p-4 font-mono text-xs text-gray-400 max-h-40 overflow-y-auto scrollbar-thin border border-white/5">
                    <div id="logs" class="space-y-1"></div>
                </div>
            </div>

            <!-- Output Area -->
            <div id="outputArea" class="hidden space-y-6">
                <h3 class="text-2xl font-bold flex items-center gap-2">
                    <span class="bg-gold-500 text-black text-xs font-black px-2 py-1 rounded">NEW</span>
                    Generated Clips
                </h3>
                <div id="clipsGrid" class="grid gap-4">
                    <!-- Clips will be injected here -->
                </div>
            </div>

        </div>
    </main>

    <footer class="py-8 border-t border-white/5 text-center px-6">
        <p class="text-xs text-gray-500">
            Powered by FFmpeg WASM & Gemini 1.5 Flash. <br>
            <a href="offer.html" class="text-gold-400 hover:underline">Download Desktop App</a> for 4K support &
            automated subtitles.
        </p>
    </footer>

    <!-- Logic -->
    <script type="module">
        import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

        // DOM Elements
        const apiKeyInput = document.getElementById('apiKey');
        const saveKeyBtn = document.getElementById('saveKeyBtn');
        const keyStatus = document.getElementById('keyStatus');
        const tabYoutube = document.getElementById('tabYoutube');
        const tabFile = document.getElementById('tabFile');
        const panelYoutube = document.getElementById('panelYoutube');
        const panelFile = document.getElementById('panelFile');
        const ytUrlInput = document.getElementById('ytUrl');
        const fetchYtBtn = document.getElementById('fetchYtBtn');
        const videoUpload = document.getElementById('videoUpload');
        const processBtn = document.getElementById('processBtn');
        const statusArea = document.getElementById('statusArea');
        const logsDiv = document.getElementById('logs');
        const outputArea = document.getElementById('outputArea');
        const clipsGrid = document.getElementById('clipsGrid');

        // State
        let ffmpeg = null;
        let videoData = null; // Blob or ArrayBuffer
        let genAI = null;
        let mode = 'youtube'; // 'youtube' or 'file'

        // --- Init ---
        const savedKey = localStorage.getItem('qlipper_gemini_key');
        if (savedKey) {
            apiKeyInput.value = savedKey;
            keyStatus.textContent = "Saved ‚úÖ";
            keyStatus.classList.add('text-green-500');
            keyStatus.classList.remove('text-gray-500');
            checkReady();
        }

        // --- Tabs ---
        function switchTab(target) {
            mode = target;
            if (target === 'youtube') {
                tabYoutube.classList.add('text-gold-400', 'border-b-2', 'border-gold-400');
                tabYoutube.classList.remove('text-gray-500');
                tabFile.classList.remove('text-gold-400', 'border-b-2', 'border-gold-400');
                tabFile.classList.add('text-gray-500');
                panelYoutube.classList.remove('hidden');
                panelFile.classList.add('hidden');
            } else {
                tabFile.classList.add('text-gold-400', 'border-b-2', 'border-gold-400');
                tabFile.classList.remove('text-gray-500');
                tabYoutube.classList.remove('text-gold-400', 'border-b-2', 'border-gold-400');
                tabYoutube.classList.add('text-gray-500');
                panelFile.classList.remove('hidden');
                panelYoutube.classList.add('hidden');
            }
            checkReady();
        }
        tabYoutube.addEventListener('click', () => switchTab('youtube'));
        tabFile.addEventListener('click', () => switchTab('file'));

        // --- Handlers ---
        saveKeyBtn.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            if (key) {
                localStorage.setItem('qlipper_gemini_key', key);
                keyStatus.textContent = "Saved ‚úÖ";
                keyStatus.classList.add('text-green-500');
                log('API Key saved locally.');
                checkReady();
            }
        });

        // File Handler
        videoUpload.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                videoData = e.target.files[0];
                log(`Selected file: ${videoData.name} (${(videoData.size / 1024 / 1024).toFixed(2)} MB)`);
                panelFile.classList.add('border-gold-500');
                checkReady();
            }
        });

        // YouTube handler (Fetch via Cobalt)
        fetchYtBtn.addEventListener('click', async () => {
            const url = ytUrlInput.value.trim();
            if (!url) return;

            fetchYtBtn.disabled = true;
            fetchYtBtn.textContent = 'Fetching...';
            log(`Resolving YouTube URL via Public API...`);

            try {
                // Using a public Cobalt instance (api.cobalt.tools is often rate limited, using a rotation or stable alternative if possible)
                // We will try a few known instances if one fails
                const instances = [
                    'https://api.cobalt.tools', // Main
                    'https://co.wuk.sh', // Backup
                    'https://cobalt.bowring.uk' // Backup
                ];

                let streamUrl = null;

                for (const instance of instances) {
                    try {
                        log(`Trying resolver: ${instance}...`);
                        const res = await fetch(`${instance}/api/json`, {
                            method: 'POST',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                url: url,
                                vCodec: 'h264',
                                vQuality: '720',
                                aFormat: 'mp3',
                                filenamePattern: 'basic'
                            })
                        });

                        const data = await res.json();
                        if (data.url) {
                            streamUrl = data.url;
                            log(`Resolved video URL!`);
                            break;
                        }
                    } catch (e) {
                        console.error(e);
                        continue;
                    }
                }

                if (!streamUrl) throw new Error("Could not resolve video URL from any provider.");

                // Now Fetch the blob (CORS might be an issue depending on the resolved URL)
                log('Downloading video data (this may take a moment)...');
                const vidRes = await fetch(streamUrl);
                if (!vidRes.ok) throw new Error("Failed to download video stream");

                const blob = await vidRes.blob();
                videoData = blob;
                log(`Video downloaded: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);

                fetchYtBtn.textContent = 'Loaded ‚úÖ';
                fetchYtBtn.classList.add('bg-green-500/20', 'text-green-500', 'border-green-500/50');
                checkReady();

            } catch (e) {
                log(`Error: ${e.message}`);
                fetchYtBtn.textContent = 'Failed ‚ùå';
                setTimeout(() => fetchYtBtn.textContent = 'Load', 3000);
                alert("Could not download video. It might be restricted or too long. Try uploading the file directly.");
            } finally {
                fetchYtBtn.disabled = false;
            }
        });

        function checkReady() {
            if (apiKeyInput.value && videoData) {
                processBtn.disabled = false;
                processBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        function log(msg) {
            statusArea.classList.remove('hidden');
            const div = document.createElement('div');
            // Timestamp
            const time = new Date().toLocaleTimeString();
            div.textContent = `[${time}] ${msg}`;
            logsDiv.appendChild(div);
            logsDiv.scrollTop = logsDiv.scrollHeight;
        }

        // Load FFmpeg Script manually to ensure control
        async function loadFFmpeg() {
            if (window.FFmpeg) return;
            const script = document.createElement('script');
            script.src = "https://unpkg.com/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.js";
            document.head.appendChild(script);
            await new Promise(r => script.onload = r);
        }

        // --- Process Workflow ---
        processBtn.addEventListener('click', async () => {
            processBtn.disabled = true;
            processBtn.textContent = "Processing... (Do not close tab)";
            statusArea.classList.remove('hidden');

            try {
                // 1. Initialize FFmpeg
                if (!ffmpeg) {
                    log('Initializing FFmpeg Engine...');
                    await loadFFmpeg();
                    const { FFmpeg } = window.FFmpeg;
                    const { toBlobURL } = window.FFmpegUtil;

                    ffmpeg = new FFmpeg();
                    const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd';
                    await ffmpeg.load({
                        coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
                        wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
                    });
                    log('FFmpeg engine ready.');
                }

                // 2. Write file
                log('Writing video to memory...');
                const { fetchFile } = window.FFmpegUtil;
                await ffmpeg.writeFile('input.mp4', await fetchFile(videoData));

                // 3. Extract Audio
                log('Extracting audio track...');
                await ffmpeg.exec(['-i', 'input.mp4', '-vn', '-acodec', 'libmp3lame', 'audio.mp3']);
                const audioData = await ffmpeg.readFile('audio.mp3');
                const audioBlob = new Blob([audioData.buffer], { type: 'audio/mp3' });

                // 4. Gemini Analysis
                log('Analyzing with Gemini 1.5 Flash...');
                genAI = new GoogleGenerativeAI(apiKeyInput.value);
                const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

                const base64Audio = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.readAsDataURL(audioBlob);
                });

                const prompt = `
                Analyze this audio for viral potential. Find exactly 3 best segments.
                Return JSON array only: [{"title": "string", "start": "MM:SS", "end": "MM:SS", "reason": "string"}]
                `;

                const result = await model.generateContent([prompt, { inlineData: { mimeType: "audio/mp3", data: base64Audio } }]);
                const text = result.response.text();
                const json = text.replace(/```json/g, '').replace(/```/g, '').trim();
                const segments = JSON.parse(json);
                log(`Found ${segments.length} clips.`);

                // 5. Generate Clips
                outputArea.classList.remove('hidden');
                clipsGrid.innerHTML = '';

                for (let i = 0; i < segments.length; i++) {
                    const seg = segments[i];
                    log(`Processing: ${seg.title}...`);

                    const start = timeToSeconds(seg.start);
                    const end = timeToSeconds(seg.end);
                    const dur = end - start;
                    const outName = `clip_${i}.mp4`;

                    await ffmpeg.exec(['-ss', `${start}`, '-i', 'input.mp4', '-t', `${dur}`, '-c', 'copy', outName]);

                    const data = await ffmpeg.readFile(outName);
                    const url = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));

                    const card = document.createElement('div');
                    card.className = 'bg-white/5 border border-white/10 rounded-xl p-4 flex flex-col sm:flex-row gap-4';
                    card.innerHTML = `
                         <video src="${url}" controls class="w-full sm:w-48 h-28 bg-black rounded-lg border border-white/10"></video>
                         <div class="flex-1">
                             <h4 class="font-bold text-white text-lg">${seg.title}</h4>
                             <p class="text-xs text-gold-400 font-mono mb-2">${seg.start} - ${seg.end}</p>
                             <p class="text-sm text-gray-400 mb-3">${seg.reason}</p>
                             <a href="${url}" download="qlipper_${seg.title.replace(/\s/g, '_')}.mp4" class="inline-block bg-gold-500 text-black font-bold px-4 py-2 rounded-lg text-sm hover:opacity-90">Download</a>
                         </div>
                    `;
                    clipsGrid.appendChild(card);
                }

                log('All Done! ‚ú®');
                processBtn.textContent = 'Start Magic Clipping ‚ú®';
                processBtn.disabled = false;

            } catch (e) {
                log(`ERROR: ${e.message}`);
                console.error(e);
                processBtn.textContent = 'Error - Try Again';
                processBtn.disabled = false;
            }
        });

        function timeToSeconds(str) {
            const p = str.trim().split(':').map(Number);
            return (p[0] * 60) + p[1];
        }

    </script>
</body>

</html>